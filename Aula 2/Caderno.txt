Engenharia de software visa desenvolver adequadamente software para atender as necessidades do usuário.

Qualidade é um conjunto de propriedades (que um software deve satisfazer)

Artefato deve satisfazer todas as necessidades explícitas(o que foi devidamente escrito) e implícitas (onde mora o grande problema)

O usuário não sabe o que quer? Errado. Ele não sabe informar o que precisa em termos que o desenvolvedor entenda claramente.

O interessado entende das regras da própria empresa, como é o trabalho no dia a dia, (em teoria deveria saber) como funciona a contabilidade.
Nem tudo é passado.

Interessado: é um papel a desempenhar. Pode ser o aluno querendo se matricular, funcionário da DAR querendo cadastrar uma informação ou um 
professor querendo acessar uma pauta.

O que é um sistema? Conjunto de elementos interdependentes (com objetivo comum)
Objetivo: produzir um resultado a partir de uma entrada de dados e controle. (No nível mais baixo dados e controle acabam sendo a mesma coisa mas enfim)

Erro: um estado do programa diferente do esperado

Estado: conjunto de valores que suas variáveis têm

Importância de colocar um observador sobre o erro para informar a respeito

Diferença entre erro x falha
Erro é desconhecido
Falha é conhecida
Mas ambos são estados não esperados

Falta <-> fault
Para não se enganar, escreva defeito

A partir da região onde se imagina que está o erro do código se coloca um breakpoint e avança passo a passo
(A famosa arte milenar de sair colocando printf até achar)

Latência: diferença de tempo/espaço entre o erro no código e a falha que ocorre. Quanto maior a latência pior a situação para resolver.
Mais tempo e mais instruções no meio

Bad smell/anomalia -> traz dificuldades para a manutenção

Desenvolver software perfeito é virtualmente impossível, exceto programas muito pequenos ou com contexto bem específico.

Risco: evento que tem possibilidade de ocorrer com impacto negativo no sistema

Risco de desenvolvimento: não conseguir entregar no prazo. Existem três riscos de desenvolvimento possíveis
1. Muitas vezes pelo projeto ter sido orçado/estimado incorretamente
2. Cliente traz novos requisitos para o sistema
3. Tecnologia empregada não é adequada para o projeto

Risco de uso
Exemplo: Deixar para fazer matrícula faltando meia hora para o fim do prazo, ficando sujeito a queda de luz, excesso de tráfego, etc

Qualidade satisfatória
Caso satisfaça todos os anseios dos interessados oferecendo riscos aceitáveis

->Ausência de impasse requer bloqueio
->Política de admitir impasse tem mais produtividade
Não peguei as duas linha acima muito bem

Nas engenharias tradicionais podemos (e devemos!) antever os problemas antes da produção
Ex: construção de uma represa

Em engenharia de software a situação é diferente mas vamo que vamo

Qualidade por construção: um programa que está correto antes do primeiro teste
Quando se termina um projeto outro engenheiro confere o que feito a fim de evitar que erros passem

CMMI: capacitação na construção de softwares
-> não garante perfeição mas provavelmente terá poucos erros

Software correto é aquele que faz o que deve fazer antes dos testes (que ainda são necessários)
Teste é feito para testar e não para defender seu emprego!

Manutenção -> pode introduzir erro onde não tinha
Com os testes apropriados é possível conseguir a corretude por manutenção

Sistema intensivo em software
Ex.: passador de slide, aparelho auditivo

O interesse não é o software mas sim resolver o problema usando o sistema intensivo em software
Ex.: querer escrever um texto usando o Microsoft Word™ 

O usuário passou a fazer parte do sistema pois recebe estímulos (ui) tal como o software

O que é um sistema correto? Implementa exatamente sua especificação.
Se a especificação está errada terá em mãos um sistema corretamente errado. Parabéns!

Qualidade = especificação

Requisitos
Funcional -> um programa capaz de somar 10 números
Não funcional - > um programa capaz de somar 10 números em x nanossegundos

É preciso tomar cuidado com a especificação. 
Por exemplo, não é necessário fazer um sistema capaz de receber dígitos do teclado mais rápido do que um digitador treinado
consegue digitar.

Não podemos garantir sempre que a especificação é correta mais ainda assim temos que especificar para poder avaliar o desempenho.

Medições que não envolvem interferência humana ou feitas por pessoal bem treinado asseguram qualidade
Ex.: Medidor mecânico de consumo de eletricidade, técnico conferindo a pintura de um carro ao sair da linha de produção,
pessoas treinadas para conferir se um perfume está certo

C é bom para quem gosta de sofrer e quem precisa de um bom domínio. Com struct/classes é possível fazer aquela
aritmética de ponteiros gostosa e ótima para gerenciadores de memória, mas péssima para todo o resto.
Java é bom para sistemas de informação
Python é bom para matemática e outras aplicações que engenheiros gostam (muitas bibliotecas disponíveis)

Código NÃO é uma boa especificação, apenas é uma solução que nem sempre é de fácil leitura

Errar é humano, perseverar no erro é coisa de loco

Mesmo um sistema perfeito pode falhar, pois depende de hardware, rede, bancos de dados, ou seja, depende de outros sistemas não perfeitos

Especificação com problema
Entenda que defeitos se propagam

Importante controlar defeitos em documentos de especificação









